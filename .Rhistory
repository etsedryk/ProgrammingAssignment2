knitr
?knitr
??knitr
x <- 4
class(x)
x <- 1:4
y <- 2:3
x + y
x <- c(17, 14, 4, 5, 13, 12, 10)
x
x[x > 10] <- 4
x
hw1_data <- read.csv("C:/Users/Egor/Desktop/Coursera/hw1_data.csv")
View(hw1_data)
x <- 1:4
y <- 2:3
x + y
class(x + y)
x <- c(1, 3, 5)
Y <- c(3, 2, 10)
rbind(x, y)
rbind(x, y)
rm(y)
y <- c(3, 2, 10)
rbind(x, y)
x <- list(2, "a", "b", TRUE)
x[[2]]
class(x[[2]])
x <- 1:4
y <- 2:3
x + y
class(x + y)
x <- 4L
class(x)
x <- matrix(1:6, 2, 3)
for(i in seq_len(nrow(x))) {
for(j in seq_len(ncol(x))) {
print(x[i, j])
}
}
if(x > 3) {
y <- 10
} else {
y <- 0
}
if(x > 3) {
y <- 10
} else {
y <- 0
}
y <- if(x > 3) {
10
} else {
0
}
y
if(x > 3) {
y <- 10
} else {
y <- 0
}
for (i in 10) {
print(i)
}
for (i in 1:10) {
print(i)
}
for (i in c(1,10)) {
print(i)
}
x <- c("a", "b", "c", "d")
for(i in 1:4) {
print(x[i])
}
for(i in seq_along(x)) {
print(x[i])
}
for(letter in x) {
print(letter)
}
for(i in 1:4) print(x[i])
count <- 0
while(count < 10) {
print(count)
count <- count + 1
}
z <- 5
while(z >= 3 && z <= 10) {
print(z)
coin <- rbinom(1, 1, 0.5)
if(coin = 1) {
z <- z + 1
} else {
z <- z - 1
}
}
x0 <- 1
tol <- le-8
repeat {
x1 <- computeEstimate()
if(abs(x1 - x0) < tol) {
break
} else {
x0 - x1
}
}
x0 <- 1
tol <- le-8
repeat {
x1 <- computEstimate()
if(abs(x1 - x0) < tol) {
break
} else {
x0 - x1
}
}
for(i in 1:100) {
if(i <= 20) {
next
}
}
args(lm)
f <- function(a, b) {
a ^ 2
}
f(2)
f(a, b)
f(2, 2)
f <- function(a, b) {
print(a)
print(b)
}
f(45)
myplot <- function(x, y, type = "1", ...) {
plot(x, y, type = type, ...)
}
myplot(2, 3)
myplot <- function(x, y, type = "1", ...) {
plot(x, y, type = type, ...)
}
myplot(10, 3)
mean
function(x, ...)
UseMean("mean")
args(paste)
paste("a", "b", sep = ":")
paste("a", "b", se = ":")
search()
make.power <- function(n) {
pow <- function(x) {
x ^ n
}
pow
}
cube <- make.power(3)
square <- make.power(2)
cube(3)
square(3)
ls(environment(cube))
get("n", environment(cube))
get("n", environment(square))
y <- 10
f <- function(x) {
y <- 2
y ^ 2 + g(x)
}
g <- function(x) {
x * y
}
f(3)
rep(10, 4)
x <- as.Date("2012-01-01")
y <- strptime("9 Jan 2011 11:34:21", "%d %b %Y %M:%S")
x - y
x <- as.Date("2012-01-01")
y <- strptime("9 Jan 2011 11:34:21", "%d %b %Y %M:%S")
x <- as.POSIXlt(x)
x - y
ube <- function(x, n) {
x ^ 3
}
cube(3)
cube <- function(x, n) {
x ^ 3
}
cube(3)
cube <- function(x, n) {
x ^ 3
}
cube(3)
x <- 1:10
if(x > 5){
x <- 0
}
x
f <- function(x) {
g <- function(y) {
y + z
}
z <- 4
x + g(x)
}
z <- 10
f(3)
f <- function(x) {
g <- function(y) {
y + z
}
z <- 4
x + g(x)
}
z <- 11
f(3)
x <- 5
y <- if(x < 3) {
NA
} else {
10
}
y
h <- function(x, y = NULL, d = 3L) {
z <- cbind(x, d)
if(!is.null(y))
z <- z + y
else
z <- z + f
g <- x + y / z
if(d == 3L)
return(g)
g <- g + 10
g
}
h(3, 5, 10)
rm(f)
h <- function(x, y = NULL, d = 3L) {
z <- cbind(x, d)
if(!is.null(y))
z <- z + y
else
z <- z + f
g <- x + y / z
if(d == 3L)
return(g)
g <- g + 10
g
}
h(3, 5, 10)
h(3, NULL, 10)
parent.frame(h)
parent.environment(h)
parent.frame()
setwd("~/Coursera/Rprog")
setwd("~/Coursera/Rprog/ProgrammingAssignment2")
## makeCacheMatrix creates a special "matrix"
## makeCacheMatrix contains four functions
makeCacheMatrix <- function(x = matrix()) {
m <- NULL
## 1. Set the value of the matrix
set <- function(y) {
x <<- y
m <<- NULL
}
## 2. Get the value of the matrix
get <- function() x
## 3. Set the value of the inverted matrix
setinverse <- function(solve) m <<- solve
## 4. Get the value of the inverted matrix
getinverse <- function() m
## Return the list of four values
list(set = set, get = get,
setinverse = setinverse,
getinverse = getinverse)
}
## cacheSolve computes the inverse of the special "matrix"
## cacheSolve can retrieve the inverse from cache
cacheSolve <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
m <- x$getinverse()
## If the inverse has already been calculated
## give a message that the inverse is retrieved from cache
if(!is.null(m)) {
message("getting cached data")
return(m)
}
## Retrieve 'x' fom cache
data <- x$get()
## Calculate the inverse of 'x' retrived from cache
m <- solve(data, ...)
## Retrieve the value of the inverse from cache
x$setinverse(m)
## Return the inverse from cache
m
}
v <- makeCacheMatrix()
v$set(c(4, 2, 7, 6), 2, 2)
v$set(c(4, 2, 7, 6), nrow = 2, ncol = 2)
v$set(c(4, 2, 7, 6))
v$get
cacheSolve(v)
a <- c(4, 2, 7, 6)
v$set(a, 2, 2)
rm(a)
rm(v)
testMatrix <- matrix(c(4, 2, 7, 6), 2, 2)
testMatrix
v <- makeCacheMatrix(testMatrix)
v$set
v$set()
v$set(testMatrix)
v$get()
cacheSolve(v)
cacheSolve(v)
testMatrix(c(5, 8, 11, 14, 17, 20, 23, 26, 29), 3, 3)
testMatrix <- matrix(c(5, 8, 11, 14, 17, 20, 23, 26, 29), 3, 3)
v <- makeCacheMatrix()
v$set(testMatrix)
v$get()
cacheSolve(testMatrix)
cacheSolve(v)
testMatrix <- matrix(c(5, 8, 11, 14, 17, 20, 23, 26, 29, 30, 43, 80, 50, 78, 67, 74), 4, 4)
v <- makeCacheMatrix(testMatrix)
v$set()
v$set(testMatrix)
v$get()
cacheSolve()
cacheSolve(v)
testMatrix(1:9, 3, 3)
testMatrix <- matrix(1:9, 3, 3)
v <- makeCacheMatrix(testMatrix)
v$set(testMatrix)
v$get()
cacheSolve(v)
testMatrix <- matrix(c(5, 8, 11, 14, 17, 20, 23, 26, 29, 30, 43, 80, 50, 78, 67, 74), 4, 4)
v <- makeCacheMatrix()
v$set(testMatrix)
v$get()
cacheSolve(v)
cacheSolve(v)
$apropos(square matrix)
?apropos(square matrix)
apropos(square matrix)
apropos(square)
apropos("square matrix")
apropos(cacheSolve)
makeVector <- function(x = numeric()) {
m <- NULL
set <- function(y) {
x <<- y
m <<- NULL
}
get <- function() x
setmean <- function(mean) m <<- mean
getmean <- function() m
list(set = set, get = get,
setmean = setmean,
getmean = getmean)
}
# Call the makeVector() function and assign its
# return value (a list of four functions) to a variable, v
# v is now a list of four functions
v <- makeVector()
# use v's set function to create a vector
# containing the numbers 20 through to 40
v$set(20:40)
# use v's get function to retrieve the vector created
v$get()
# pass the list v to the cachemean() function
# the mean of the numeric vector 20:40 should be returned
cachemean(v)
# pass the list v to the cachemean() function a second time
# the mean of the numeric vector 20:40 should be returned
# also a message "retrieving value from cache" indicating that the mean
# is not being calculated this time but is being retrieved from the cached
# value
cachemean(v)
# use v's set function to create a new vector
# containing the numbers 23,23,34.6,654.35
v$set(c(23,23,34.6,654.35))
# pass the list v to the cachemean() function
# the mean of the numeric vector 23,23,34.6,654.35 should be returned
cachemean(v)
# pass the list v to the cachemean() function a second time
# the mean of the numeric vector 23,23,34.6,654.35 should be returned
# also a message "retrieving value from cache" indicating that the mean
# is not being calculated this time but is being retrieved from the cached
# value
cachemean(v)
makeVector <- function(x = numeric()) {
m <- NULL
set <- function(y) {
x <<- y
m <<- NULL
}
get <- function() x
setmean <- function(mean) m <<- mean
getmean <- function() m
list(set = set, get = get,
setmean = setmean,
getmean = getmean)
}
v <- makeVector()
v$set(20:40)
v$get()
cachemean(v)
rm(makeVector)
rm(v)
## makeCacheMatrix creates a special "matrix"
## makeCacheMatrix contains four functions
makeCacheMatrix <- function(x = matrix()) {
m <- NULL
## 1. Set the value of the matrix
set <- function(y) {
x <<- y
m <<- NULL
}
## 2. Get the value of the matrix
get <- function() x
## 3. Set the value of the inverted matrix
setinverse <- function(solve) m <<- solve
## 4. Get the value of the inverted matrix
getinverse <- function() m
## Return the list of four values
list(set = set, get = get,
setinverse = setinverse,
getinverse = getinverse)
}
## cacheSolve computes the inverse of the special "matrix"
## cacheSolve can retrieve the inverse from cache
cacheSolve <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
m <- x$getinverse()
## If the inverse has already been calculated
## give a message that the inverse is retrieved from cache
if(!is.null(m)) {
message("getting cached data")
return(m)
}
## Retrieve 'x' fom cache
data <- x$get()
## Calculate the inverse of 'x' retrived from cache
m <- solve(data, ...)
## Retrieve the value of the inverse from cache
x$setinverse(m)
## Return the inverse from cache
m
}
